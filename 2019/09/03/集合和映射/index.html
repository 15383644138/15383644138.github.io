<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>集合和映射 | 人间且慢行</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><meta name="referrer" content="no-referrer-when-downgrade"><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">集合和映射</h1><a id="logo" href="/.">人间且慢行</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">集合和映射</h1><div class="post-meta">Sep 3, 2019<span> | </span><span class="category"><a href="/categories/基础知识/">基础知识</a></span><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#集合和映射（Set-and-Map"><span class="toc-number">1.</span> <span class="toc-text">集合和映射（Set and Map)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">1.1.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于二分搜索树的集合"><span class="toc-number">1.1.1.</span> <span class="toc-text">基于二分搜索树的集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于链表的集合实现"><span class="toc-number">1.2.</span> <span class="toc-text">基于链表的集合实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#集合的时间复杂度分析"><span class="toc-number">1.2.1.</span> <span class="toc-text">集合的时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#leetcode应用"><span class="toc-number">1.2.2.</span> <span class="toc-text">leetcode应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序集合和无序集合"><span class="toc-number">1.2.3.</span> <span class="toc-text">有序集合和无序集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重集合"><span class="toc-number">1.2.4.</span> <span class="toc-text">多重集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#映射Map"><span class="toc-number">1.3.</span> <span class="toc-text">映射Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现以链表为底层数据结构的映射类"><span class="toc-number">1.3.1.</span> <span class="toc-text">实现以链表为底层数据结构的映射类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#节点内部类"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">节点内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数以及2个简单函数"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">构造函数以及2个简单函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#辅助函数getNode"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">辅助函数getNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#contains、get、add函数"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">contains、get、add函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set和remove函数"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">set和remove函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试用例"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">测试用例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于二分搜索树实现映射类"><span class="toc-number">1.3.2.</span> <span class="toc-text">基于二分搜索树实现映射类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#添加：add函数"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">添加：add函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查询，修改"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">查询，修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试用例-1"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">测试用例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#映射时间复杂度分析以及其他相关"><span class="toc-number">1.3.3.</span> <span class="toc-text">映射时间复杂度分析以及其他相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序映射和无序映射"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">有序映射和无序映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多重映射"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">多重映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合和映射的关系"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">集合和映射的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#leetcod相关练习"><span class="toc-number">1.3.4.</span> <span class="toc-text">leetcod相关练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#leetcode：349-两个数组的交集"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">leetcode：349. 两个数组的交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#350-给定两个数组，编写一个函数来计算它们的交集。"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">350.给定两个数组，编写一个函数来计算它们的交集。</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="post-content"><h1 id="集合和映射（Set-and-Map"><a href="#集合和映射（Set-and-Map" class="headerlink" title="集合和映射（Set and Map)"></a>集合和映射（Set and Map)</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合：承载元素的容器，每个元素只能存在一次，他能帮我们快速的实现去重这个操作。上一篇我们实现的二分搜索树就是不能盛放重复元素的，所以它是非常好的实现“集合”的底层数据结构。</p>
<h3 id="基于二分搜索树的集合"><a href="#基于二分搜索树的集合" class="headerlink" title="基于二分搜索树的集合"></a>基于二分搜索树的集合</h3><p><strong>需要支持的接口</strong></p>
<p>Set<e></e></p>
<ul>
<li>void add(E)</li>
<li>void remove(E)</li>
<li>boolean contains(E)//判断集合中是否包含元素E</li>
<li>int getSize()//返回当前集合中一共有多少元素</li>
<li>boolean isEmpty()//是否为空</li>
</ul>
<p>应用：ip统计，词汇量统计，客户统计</p>
<p>需要上一节二分搜索树的实现类</p>
<p>定义一个接口Set<e></e></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Set&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void <span class="builtin-name">add</span>(E e);</span><br><span class="line">    void <span class="builtin-name">remove</span>(E e);</span><br><span class="line">    boolean contains(E e);</span><br><span class="line">    int getSize();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现接口</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BST&lt;E&gt; bst;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bst = <span class="keyword">new</span> BST&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> bst.<span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> bst.<span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        bst.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> bst.<span class="title">contains</span><span class="params">(e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        bst.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：英文原版书词汇量统计</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.io.<span class="keyword">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件相关操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> FileOperation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件名称为filename中的内容，并将其中包含的所有词语放进words中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> readFile(String filename, ArrayList&lt;String&gt; words)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span> || words == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"filename is null or words is null"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件读取</span></span><br><span class="line">        Scanner scanner;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(filename);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">file</span>.exists())&#123;</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">file</span>);</span><br><span class="line">                scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(fis), <span class="string">"UTF-8"</span>);</span><br><span class="line">                scanner.useLocale(Locale.ENGLISH);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(IOException ioe)&#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"Cannot open "</span> + filename);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单分词</span></span><br><span class="line">        <span class="comment">// 这个分词方式相对简陋, 没有考虑很多文本处理中的特殊问题</span></span><br><span class="line">        <span class="comment">// 在这里只做demo展示用</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextLine()) &#123;</span><br><span class="line"></span><br><span class="line">            String contents = scanner.useDelimiter(<span class="string">"\\A"</span>).<span class="keyword">next</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> start = firstCharacterIndex(contents, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= contents.length(); )</span><br><span class="line">                <span class="keyword">if</span> (i == contents.length() || !Character.isLetter(contents.charAt(i))) &#123;</span><br><span class="line">                    String word = contents.substring(start, i).toLowerCase();</span><br><span class="line">                    words.add(word);</span><br><span class="line">                    start = firstCharacterIndex(contents, i);</span><br><span class="line">                    i = start + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找字符串s中，从start的位置开始的第一个字母字符的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> firstCharacterIndex(String s, <span class="keyword">int</span> start)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = start ; i &lt; s.length() ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( Character.isLetter(s.charAt(i)) )</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Main &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Pride and Prejudice"</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;<span class="keyword">String</span>&gt; words1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将pride-and-prejudice文件中的单词存进words1中</span></span><br><span class="line">        <span class="built_in">if</span>(FileOperation.readFile(<span class="string">"pride-and-prejudice.txt"</span>, words1)) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Total words: "</span> + words1.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由于二分搜索树中不包含重复元素，就实现了去重</span></span><br><span class="line">            BSTSet&lt;<span class="keyword">String</span>&gt; set1 = <span class="keyword">new</span> BSTSet&lt;&gt;();</span><br><span class="line">            <span class="built_in">for</span> (<span class="keyword">String</span> <span class="keyword">word</span> : words1)</span><br><span class="line">                set1.add(<span class="keyword">word</span>);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Total different words: "</span> + set1.getSize());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"A Tale of Two Cities"</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;<span class="keyword">String</span>&gt; words2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">if</span>(FileOperation.readFile(<span class="string">"a-tale-of-two-cities.txt"</span>, words2))&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Total words: "</span> + words2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">            BSTSet&lt;<span class="keyword">String</span>&gt; set2 = <span class="keyword">new</span> BSTSet&lt;&gt;();</span><br><span class="line">            <span class="built_in">for</span>(<span class="keyword">String</span> <span class="keyword">word</span>: words2)</span><br><span class="line">                set2.add(<span class="keyword">word</span>);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Total different words: "</span> + set2.getSize());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190818/6GYSpTa4Nt.png" alt="1"></p>
<h2 id="基于链表的集合实现"><a href="#基于链表的集合实现" class="headerlink" title="基于链表的集合实现"></a>基于链表的集合实现</h2><p><strong>为何要使用链表实现</strong></p>
<ul>
<li>BST 和LinkedList都属于动态数据结构，当使用它们两种实现后可以相应地比较性能，看到二分搜索树的优势所在。</li>
</ul>
<p>需要链表的实现类</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> list.<span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> list.<span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> list.<span class="title">contains</span><span class="params">(e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!list.contains(e))</span><br><span class="line">            list.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        list.removeElement(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数只需要把创建的类型改一下就好</p>
<p> <code>BSTSet&lt;String&gt; set1 = new BSTSet&lt;&gt;();</code>变为</p>
<p><code>LinkedListSet&lt;String&gt; set1 = new LinkedListSet&lt;&gt;();</code></p>
<p>运行的时候用链表实现的集合明显感觉慢了很多。</p>
<h3 id="集合的时间复杂度分析"><a href="#集合的时间复杂度分析" class="headerlink" title="集合的时间复杂度分析"></a>集合的时间复杂度分析</h3><p>LinkedListSet</p>
<ul>
<li>增：add :O(n)<ul>
<li>linkedListSet:为了保证链表中元素不重复，需要首先查一遍链表，确定要添加的元素在当前链表中不存在，而这个查的过程是一个O(n)级别的复杂度，使得增这个操作的时间复杂度是O(n)这个级别。</li>
</ul>
</li>
<li>查：contains  :O(n)</li>
<li>删：需要先找到要删除元素前面的元素，因此时间复杂度也是O(n)。</li>
</ul>
<p>BSTSet: 添加一个元素类似于走一个链表，最多能经历的节点是这棵二分搜索树树的高度（h)</p>
<ul>
<li>增：O(h)</li>
<li>查：O(h)</li>
<li>删：O(H)</li>
</ul>
<p>满二分搜索树树节点个数<br><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190818/WhCMhArmy2.png" alt="2"></p>
<p>log的底我们一般忽略不记，因为是线性的。<br><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190818/GrkfaieAYm.png" alt="image"></p>
<p><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190818/8yyikzDMDW.png" alt="4"></p>
<p>但是对于我们之前实现的二分搜索树有一个缺陷，就是有一个最坏情况，对于同样数据我们可以创建出不同的树。</p>
<p><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190818/pBaCMcJCdY.png" alt="5"></p>
<p>右边这种情况下，二分搜索树和一个链表是一样的，高度等于节点个数，当我们把123456按顺序添加则可以复现退化成为链表的二分搜索树，平衡二叉树可以解决这个问题。<br><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190818/Mfm2Ap6dBS.png" alt="6"></p>
<h3 id="leetcode应用"><a href="#leetcode应用" class="headerlink" title="leetcode应用"></a>leetcode应用</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: <span class="string">"a"</span> 对应 <span class="string">".-"</span>, <span class="string">"b"</span> 对应 <span class="string">"-..."</span>, <span class="string">"c"</span> 对应 <span class="string">"-.-."</span>, 等等。</span><br><span class="line"></span><br><span class="line">为了方便，所有<span class="number">26</span>个英文字母对应摩尔斯密码表如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，<span class="string">"cab"</span> 可以写成 <span class="string">"-.-..--..."</span>，(即 <span class="string">"-.-."</span> + <span class="string">"-..."</span> + <span class="string">".-"</span>字符串的结合)。我们将这样一个连接过程称作单词翻译。</span><br><span class="line"></span><br><span class="line">返回我们可以获得所有词不同单词翻译的数量。</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">输入: words = [<span class="string">"gin"</span>, <span class="string">"zen"</span>, <span class="string">"gig"</span>, <span class="string">"msg"</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: </span><br><span class="line">各单词翻译如下:</span><br><span class="line"><span class="string">"gin"</span> -&gt; <span class="string">"--...-."</span></span><br><span class="line"><span class="string">"zen"</span> -&gt; <span class="string">"--...-."</span></span><br><span class="line"><span class="string">"gig"</span> -&gt; <span class="string">"--...--."</span></span><br><span class="line"><span class="string">"msg"</span> -&gt; <span class="string">"--...--."</span></span><br><span class="line"></span><br><span class="line">共有 <span class="number">2</span> 种不同翻译, <span class="string">"--...-."</span> 和 <span class="string">"--...--."</span>.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">单词列表words 的长度不会超过 <span class="number">100</span>。</span><br><span class="line">每个单词 words[i]的长度范围为 [<span class="number">1</span>, <span class="number">12</span>]。</span><br><span class="line">每个单词 words[i]只包含小写字母。</span><br><span class="line"></span><br><span class="line">来源：力扣（<span class="symbol">LeetCode</span>）</span><br></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> uniqueMorseRepresentations(<span class="keyword">String</span>[] words) &#123;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span>[] codes = &#123;<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>&#125;;</span><br><span class="line">        TreeSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> word: words)&#123;</span><br><span class="line">            StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; word.length() ; i ++)</span><br><span class="line">                res.<span class="built_in">append</span>(codes[word.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">set</span>.<span class="built_in">add</span>(res.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序集合和无序集合"><a href="#有序集合和无序集合" class="headerlink" title="有序集合和无序集合"></a>有序集合和无序集合</h3><ul>
<li>有序集合中的元素具有顺序性（轻易从小到大遍历它们，知道它上一个或下一个元素是谁）——————基于搜索树实现</li>
<li>无序集合中的元素没有顺序性（无法进行查找第n个元素，找到最大元素，最小元素等等）——————基于哈希表实现（本文基于链表实现的无序集合效率较低）</li>
<li>可以理解为对于搜索树的实现来说，如果保持有序性，它的能力就更大（轻易查找最大元素，最小元素，第n个元素等等，这样的代价就是时间复杂度略差于哈希表）</li>
</ul>
<h3 id="多重集合"><a href="#多重集合" class="headerlink" title="多重集合"></a>多重集合</h3><p>集合中的元素可以重复（可以在二分搜索树中条件设置为可以重复，包装一下就可以实现）</p>
<h2 id="映射Map"><a href="#映射Map" class="headerlink" title="映射Map"></a>映射Map</h2><p>我们高中数学<br>所学的函数我们可以理解为映射（一一映射）比如：1对应3,2对应5</p>
<p>字典中：单词对应释义，名册中：身份证号对应人，数据库中：id对应信息<br><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190901/7FjwpBRpjM.png" alt="1（2）"></p>
<p>python中也叫做字典（dict），而在java，c++中称之为Map，这种存储方式本质上是（我们称之为key和value）key和value相对应的存储方式。</p>
<ul>
<li>总结：存储（键、值）数据对的数据结构（Key，Value)</li>
<li>一般情况是为了：根据键(Key)来寻找值(Value)</li>
<li>非常容易使用链表或者二分搜索树实现</li>
</ul>
<p><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190901/5j26PEmhdm.png" alt="2（2）"></p>
<p>具体的实现方法：<br>之前实现集合时，二分搜索树的Node中存储的只有一个元素e，而现在Node节点需要存储两个数据，key和value</p>
<p><strong>需要实现的接口</strong></p>
<ul>
<li>Map&lt;K,V&gt;</li>
<li>void add(K,V)</li>
<li>V remove(K)//根据传入的key删除数据，返回value</li>
<li>boolean contains(K)//查看键k的数据是否存在，理解为：翻字典只需要知道字典里有没有这个单词就可以，不用管它的释义。</li>
<li>V get（K）获取键为key的值（返回Value）</li>
<li>void set(K,V)//修改这个键在Map中对应的值的信息</li>
<li>int getSize()</li>
<li>boolean isEmpty()<br><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190901/4kjM2xRTWK.png" alt="3（2）"></li>
</ul>
<h3 id="实现以链表为底层数据结构的映射类"><a href="#实现以链表为底层数据结构的映射类" class="headerlink" title="实现以链表为底层数据结构的映射类"></a>实现以链表为底层数据结构的映射类</h3><h4 id="节点内部类"><a href="#节点内部类" class="headerlink" title="节点内部类"></a>节点内部类</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span>  <span class="title">Node</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> K key;</span><br><span class="line">     <span class="keyword">public</span> V <span class="keyword">value</span>;</span><br><span class="line">     <span class="keyword">public</span> Node next;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params">K key,V <span class="keyword">value</span>,Node next</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.key = key;</span><br><span class="line">         <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params">K key</span>)</span>&#123;<span class="keyword">this</span>(key,<span class="literal">null</span>,<span class="literal">null</span>);&#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>(<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);&#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> key.toString() + <span class="string">" : "</span> + <span class="keyword">value</span>.toString();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数以及2个简单函数"><a href="#构造函数以及2个简单函数" class="headerlink" title="构造函数以及2个简单函数"></a>构造函数以及2个简单函数</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node dummyHead;<span class="comment">//虚拟头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedListMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> Node();</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> size;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> size == <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="辅助函数getNode"><a href="#辅助函数getNode" class="headerlink" title="辅助函数getNode"></a>辅助函数getNode</h4><p>作用是：传来一个key返回key的值对应的节点相应的引用</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Node <span class="built_in">getNode</span>(K <span class="built_in">key</span>)&#123;</span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="built_in">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="built_in">key</span>.<span class="built_in">equals</span>(<span class="built_in">key</span>))</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="contains、get、add函数"><a href="#contains、get、add函数" class="headerlink" title="contains、get、add函数"></a>contains、get、add函数</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override//查看键k的数据是否存在</span><br><span class="line">    public<span class="built_in"> boolean</span><span class="built_in"> contains</span>(K<span class="built_in"> key</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode<span class="built_in">(key</span>) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override//获取键<span class="built_in">为key</span>的值</span><br><span class="line">    public V get(K<span class="built_in"> key</span>)&#123;</span><br><span class="line">        Node <span class="type">node</span> = getNode<span class="built_in">(key</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="type">node</span> == null ? null : <span class="type">node</span>.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(K<span class="built_in"> key</span>,V <span class="keyword">value</span>)&#123;</span><br><span class="line">        //不允许出现同样<span class="built_in">的key</span>，也就是说对于字典来说不应该有两个词条对一个名词进行解释</span><br><span class="line">        Node <span class="type">node</span> = getNode<span class="built_in">(key</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">node</span> == null)&#123;</span><br><span class="line">            dummyHead.<span class="keyword">next</span> = new Node<span class="built_in">(key</span>,<span class="keyword">value</span>,dummyHead.<span class="keyword">next</span>);//虚拟头结点的<span class="keyword">next</span>也就是我们的第一个节点</span><br><span class="line">            size ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>//否则，我们认为新传入<span class="built_in">的key</span>对应的<span class="keyword">value</span>是用户现在需要的，因此进行更新</span><br><span class="line">            <span class="type">node</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="set和remove函数"><a href="#set和remove函数" class="headerlink" title="set和remove函数"></a>set和remove函数</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void <span class="built_in">set</span>(K <span class="built_in">key</span>,V newValue)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找是否有包含key对应的节点</span></span><br><span class="line">    Node node = getNode(<span class="built_in">key</span>);</span><br><span class="line">    if(node == <span class="built_in">null</span>)</span><br><span class="line">        throw new IllegalArgumentException(<span class="built_in">key</span> + <span class="string">"doesn't exist"</span>);</span><br><span class="line"></span><br><span class="line">    node.<span class="built_in">value</span> = newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public V remove(K <span class="built_in">key</span>)&#123;</span><br><span class="line"></span><br><span class="line">    Node <span class="built_in">prev</span> = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">prev</span>.<span class="built_in">next</span> != <span class="built_in">null</span>)&#123;</span><br><span class="line">        if(<span class="built_in">prev</span>.<span class="built_in">next</span>.<span class="built_in">key</span>.equals(<span class="built_in">key</span>))</span><br><span class="line">            break;</span><br><span class="line">        <span class="built_in">prev</span> = <span class="built_in">prev</span>.<span class="built_in">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(<span class="built_in">prev</span>.<span class="built_in">next</span> != <span class="built_in">null</span>)&#123;</span><br><span class="line">        Node delNode = <span class="built_in">prev</span>.<span class="built_in">next</span>;</span><br><span class="line">        <span class="built_in">prev</span>.<span class="built_in">next</span> = delNode.<span class="built_in">next</span>;</span><br><span class="line">        delNode.<span class="built_in">next</span> = <span class="built_in">null</span>;</span><br><span class="line">        size ++;</span><br><span class="line">        return delNode.<span class="built_in">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>需要用到一个文件读取的类FileOperation（上面有，在实现集合的时候也用到过）</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> [] args)&#123;</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Pride and Prejudice"</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;<span class="keyword">String</span>&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="built_in">if</span>(FileOperation.readFile(<span class="string">"pride-and-prejudice.txt"</span>, words))&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Total words: "</span> + words.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        LinkedListMap&lt;<span class="keyword">String</span>,Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> LinkedListMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">String</span> <span class="keyword">word</span>:words) &#123;</span><br><span class="line">            <span class="built_in">if</span> (<span class="built_in">map</span>.contains(<span class="keyword">word</span>))</span><br><span class="line">                <span class="built_in">map</span>.set(<span class="keyword">word</span>, <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="keyword">word</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">else</span></span><br><span class="line">                <span class="built_in">map</span>.add(<span class="keyword">word</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Total different words: "</span> + <span class="built_in">map</span>.getSize());<span class="comment">//不同的单词</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Frequency of PRIDE: "</span> + <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"pride"</span>));<span class="comment">//查看pride这个单词的词频</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Frequency of PREJUDICE: "</span> + <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"prejudice"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190901/mADZmWDhMe.png" alt="4（2）"></p>
<h3 id="基于二分搜索树实现映射类"><a href="#基于二分搜索树实现映射类" class="headerlink" title="基于二分搜索树实现映射类"></a>基于二分搜索树实现映射类</h3><p>注意：二分搜索树是有限制的，key必须是可以比较的(实现Comparable接口)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left,right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="添加：add函数"><a href="#添加：add函数" class="headerlink" title="添加：add函数"></a>添加：add函数</h4><p>与二分搜索树逻辑一样，区别就是把传入的元素E变为key和value</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//向二分搜索树中添加新的元素<span class="built_in">（key</span>, <span class="keyword">value</span>）</span><br><span class="line"> @Override</span><br><span class="line"> public void add(K<span class="built_in"> key</span>,V <span class="keyword">value</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"> root</span> = add<span class="built_in">(root</span>,<span class="built_in"> key</span>, <span class="keyword">value</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> //向以<span class="type">node</span>为根的二分搜索树中插入元素<span class="built_in">（key</span>,<span class="keyword">value</span>），递归算法</span><br><span class="line"> //返回插入新节点后二分搜索树的根</span><br><span class="line"> private Node add(Node <span class="type">node</span>,K<span class="built_in"> key</span>,V <span class="keyword">value</span>)&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(<span class="type">node</span> == null)&#123;</span><br><span class="line">         size ++;</span><br><span class="line">         <span class="keyword">return</span> new Node<span class="built_in">(key</span>,<span class="keyword">value</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     //没有递归到底只<span class="built_in">对key</span>进行比较</span><br><span class="line">     <span class="keyword">if</span><span class="built_in">(key</span>.compareTo(<span class="type">node</span><span class="built_in">.key</span>) &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="type">node</span>.left = add(<span class="type">node</span>.left,<span class="built_in"> key</span>, <span class="keyword">value</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span><span class="built_in">(key</span>.compareTo(<span class="type">node</span><span class="built_in">.key</span>) &gt; <span class="number">0</span>)</span><br><span class="line">         <span class="type">node</span>.right = add(<span class="type">node</span>.right,<span class="built_in"> key</span>, <span class="keyword">value</span>);</span><br><span class="line">     <span class="keyword">else</span>//key.compareTo(<span class="type">node</span><span class="built_in">.key</span>)==<span class="number">0</span>;如果映射中已经存在了当前对应的节点，现在的<span class="keyword">value</span>可能与用户的<span class="keyword">value</span>不一样，因此进行替换</span><br><span class="line">         <span class="type">node</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="type">node</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询，修改"><a href="#查询，修改" class="headerlink" title="查询，修改"></a>查询，修改</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//返回以<span class="keyword">node</span><span class="title">为根节点的二分搜索树中key</span>所在的节点</span><br><span class="line">  private <span class="keyword">Node</span> <span class="title">getNode</span>(<span class="keyword">Node</span> <span class="title">node</span>, K key)&#123;</span><br><span class="line"></span><br><span class="line">      if(<span class="keyword">node</span> <span class="title">== null</span>)</span><br><span class="line">          return null;</span><br><span class="line"></span><br><span class="line">      if(key.compareTo(<span class="keyword">node</span>.<span class="title">key</span>) == <span class="number">0</span>)</span><br><span class="line">          return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">      else</span> if(key.compareTo(<span class="keyword">node</span>.<span class="title">key</span>) <span class="tag">&lt; 0)</span></span><br><span class="line"><span class="tag">          return getNode(node.left, key);</span></span><br><span class="line"><span class="tag">      else//key.compareTo(node.key) &gt;</span> <span class="number">0</span></span><br><span class="line">          return getNode(<span class="keyword">node</span>.<span class="title">right</span>,key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override//查看是否存在</span><br><span class="line">  public boolean contains(K key)&#123;</span><br><span class="line">      return getNode(root,key) != null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override//查询</span><br><span class="line">  public V get(K key)&#123;</span><br><span class="line">      <span class="keyword">Node</span> <span class="title">node</span> = getNode(root, key);</span><br><span class="line">      return <span class="keyword">node</span> <span class="title">== null</span> ? null : <span class="keyword">node</span>.<span class="title">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override//修改</span><br><span class="line">  public void set(K key, V newValue)&#123;</span><br><span class="line">      <span class="keyword">Node</span> <span class="title">node</span> = getNode(root, key);</span><br><span class="line">      if(<span class="keyword">node</span> <span class="title">== null</span>)</span><br><span class="line">          throw new IllegalArgumentException(key + <span class="string">"doesn't exist!"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">node</span>.<span class="title">value</span> = newValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 返回以<span class="keyword">node</span><span class="title">为根的二分搜索树的最小值所在的节点</span></span><br><span class="line"><span class="title">private</span> <span class="keyword">Node</span> <span class="title">minimum</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">    if(<span class="keyword">node</span>.<span class="title">left</span> == null)</span><br><span class="line">        return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    return</span> minimum(<span class="keyword">node</span>.<span class="title">left</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除掉以<span class="keyword">node</span><span class="title">为根的二分搜索树中的最小节点</span></span><br><span class="line"><span class="title">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="title">private</span> <span class="keyword">Node</span> <span class="title">removeMin</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line"></span><br><span class="line">    if(<span class="keyword">node</span>.<span class="title">left</span> == null)&#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">rightNode</span> = <span class="keyword">node</span>.<span class="title">right</span>;</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">right</span> = null;</span><br><span class="line">        size --;</span><br><span class="line">        return rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">node</span>.<span class="title">left</span> = removeMin(<span class="keyword">node</span>.<span class="title">left</span>);</span><br><span class="line">    return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title">//从二分搜索树中删除键为key</span>所对应的节点</span><br><span class="line">@Override</span><br><span class="line">public V remove(K key)&#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = getNode(root, key);</span><br><span class="line">    if(<span class="keyword">node</span> <span class="title">!= null</span>)&#123;</span><br><span class="line">        root = remove(root, key);</span><br><span class="line">        return <span class="keyword">node</span>.<span class="title">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除掉以<span class="keyword">node</span><span class="title">为根的二分搜索树中键为Key</span>对应的节点，递归算法</span><br><span class="line">//返回删除节点后新的二分搜索树的根</span><br><span class="line"><span class="keyword">Node</span> <span class="title">remove</span>(<span class="keyword">Node</span> <span class="title">node</span>, K key)&#123;</span><br><span class="line"></span><br><span class="line">    if(<span class="keyword">node</span> <span class="title">== null</span>)</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    if(key.compareTo(<span class="keyword">node</span>.<span class="title">key</span>) <span class="tag">&lt; 0)&#123;</span></span><br><span class="line"><span class="tag">        node.left = remove(node.left, key);</span></span><br><span class="line"><span class="tag">        return node;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">    else if(key.compareTo(node.key) &gt;</span> <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">right</span> = remove(<span class="keyword">node</span>.<span class="title">right</span>, key);</span><br><span class="line">        return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">    else</span>&#123;//key.compareTo(<span class="keyword">node</span>.<span class="title">key</span>)==<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        //待删除节点左子树为空的情况</span><br><span class="line">        if(<span class="keyword">node</span>.<span class="title">left</span> == null)&#123;</span><br><span class="line">            <span class="keyword">Node</span> <span class="title">rightNode</span> = <span class="keyword">node</span>.<span class="title">right</span>;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">right</span> = null;</span><br><span class="line">            size --;</span><br><span class="line">            return rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        // 待删除节点右子树为空的情况</span><br><span class="line">        if(<span class="keyword">node</span>.<span class="title">right</span> == null)&#123;</span><br><span class="line">            <span class="keyword">Node</span> <span class="title">leftNode</span> = <span class="keyword">node</span>.<span class="title">left</span>;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">left</span> = null;</span><br><span class="line">            size --;</span><br><span class="line">            return leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        // 待删除节点左右子树均不为空的情况</span><br><span class="line"></span><br><span class="line">        // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span><br><span class="line">        // 用这个节点顶替待删除节点的位置</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">successor</span> = minimum(<span class="keyword">node</span>.<span class="title">right</span>);</span><br><span class="line">        //  size ++;</span><br><span class="line"></span><br><span class="line">        successor.right = removeMin(<span class="keyword">node</span>.<span class="title">right</span>);</span><br><span class="line">        successor.left = <span class="keyword">node</span>.<span class="title">left</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">node</span>.<span class="title">left</span> = <span class="keyword">node</span>.<span class="title">right</span> = null;</span><br><span class="line">        //  size --;</span><br><span class="line"></span><br><span class="line">        return successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> [] args)&#123;</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Pride and Prejudice"</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;<span class="keyword">String</span>&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="built_in">if</span>(FileOperation.readFile(<span class="string">"pride-and-prejudice.txt"</span>, words))&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Total words: "</span> + words.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">       BSTMap&lt;<span class="keyword">String</span>,Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> BSTMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">String</span> <span class="keyword">word</span>:words) &#123;</span><br><span class="line">            <span class="built_in">if</span> (<span class="built_in">map</span>.contains(<span class="keyword">word</span>))</span><br><span class="line">                <span class="built_in">map</span>.set(<span class="keyword">word</span>, <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="keyword">word</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">else</span></span><br><span class="line">                <span class="built_in">map</span>.add(<span class="keyword">word</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Total different words: "</span> + <span class="built_in">map</span>.getSize());<span class="comment">//不同的单词</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Frequency of PRIDE: "</span> + <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"pride"</span>));<span class="comment">//查看pride这个单词的词频</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Frequency of PREJUDICE: "</span> + <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"prejudice"</span>));</span><br><span class="line">        System.out.<span class="built_in">println</span>( <span class="string">"Romove PRIDE： "</span>+ <span class="built_in">map</span>.<span class="built_in">remove</span>(<span class="string">"pride"</span>));<span class="comment">//删除pride这个单词的词频</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Frequency of PRIDE: "</span> + <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"pride"</span>));<span class="comment">//查看pride这个单词的词频</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190902/ie6dWmBZkb.png" alt="5"></p>
<h3 id="映射时间复杂度分析以及其他相关"><a href="#映射时间复杂度分析以及其他相关" class="headerlink" title="映射时间复杂度分析以及其他相关"></a>映射时间复杂度分析以及其他相关</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190902/QzRBeEJzte.png" alt="6"></p>
<h4 id="有序映射和无序映射"><a href="#有序映射和无序映射" class="headerlink" title="有序映射和无序映射"></a>有序映射和无序映射</h4><ul>
<li>有序映射中的键具有顺序性——基于搜索树实现</li>
<li>无须因三个号中的键没有顺序性——基于哈希表实现（本文基于链表实现的也是无序映射但是它太慢了）</li>
</ul>
<h4 id="多重映射"><a href="#多重映射" class="headerlink" title="多重映射"></a>多重映射</h4><p>在有些情况下，我们需要键可以重复因此定义了多重映射</p>
<ul>
<li>多重映射中的键可以重复</li>
</ul>
<h4 id="集合和映射的关系"><a href="#集合和映射的关系" class="headerlink" title="集合和映射的关系"></a>集合和映射的关系</h4><p><img src="http://yuntu88.oss-cn-beijing.aliyuncs.com/fromlocal/2896251617@qq.com/20190902/pfHZXHm3Rp.png" alt="7"><br>我们在实现集合和映射时可以使用链表来实现也可以使用二分搜索树来实现它们，其中有很多相同之处。</p>
<p>我们可以理解为：对于映射来说，本身也是一个集合，只不过是一个键key这样的集合，而且每一个键携带了一个value，本质和集合并没有区别。在很多系统类库中，我们完全可以基于集合的实现来实现映射，或者基于映射的实现来实现集合。</p>
<p>假设有一个集合实现了，我们要做的是定义集合中的元素是&lt;K,V&gt;键值对，并且要强调比较的时候要以键key的值来比较的，而不去管value的值，</p>
<p>而更常见的方式是基于映射来包装出集合，可以理解成集合为映射中&lt;K,V&gt;value为空的情况，对于不管什么情况它的value都为空，只考虑键，此时就是键的集合</p>
<hr>
<h3 id="leetcod相关练习"><a href="#leetcod相关练习" class="headerlink" title="leetcod相关练习"></a>leetcod相关练习</h3><h4 id="leetcode：349-两个数组的交集"><a href="#leetcode：349-两个数组的交集" class="headerlink" title="leetcode：349. 两个数组的交集"></a>leetcode：349. 两个数组的交集</h4><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums1 = <span class="string">[1,2,2,1]</span>, nums2 = <span class="string">[2,2]</span></span><br><span class="line">输出: <span class="string">[2]</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums1 = <span class="string">[4,9,5]</span>, nums2 = <span class="string">[9,4,9,8,4]</span></span><br><span class="line">输出: <span class="string">[9,4]</span></span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>输出结果中的每个元素一定是唯一的。<br>我们可以不考虑输出结果的顺序。</p>
<p>分析：要求结果中每一个元素唯一，显然需要借助集合（set）这种数据结构了</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">int</span>[] intersection(<span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Integer&gt; <span class="keyword">set</span> = <span class="keyword">new</span> TreeSet&lt;&gt;();<span class="comment">//初始化</span></span><br><span class="line">        <span class="comment">//把nums1中的元素扔进集合中，如果有重复元素，也已经去重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> <span class="built_in">num</span>: nums1)</span><br><span class="line">            <span class="keyword">set</span>.add(<span class="built_in">num</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放相同的元素</span></span><br><span class="line">        <span class="comment">//遍历nums2，看有多少元素可以在集合中找到</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> <span class="built_in">num</span>: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">set</span>.contains(<span class="built_in">num</span>))&#123;</span><br><span class="line">                list.add(<span class="built_in">num</span>);</span><br><span class="line">                <span class="keyword">set</span>.remove(<span class="built_in">num</span>);<span class="comment">//删除去重后的nums1中的相同元素，这样下次就找不到了一样的元素，解决了nums2中没有去重的问题</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回一个int型数组</span></span><br><span class="line">        <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.size(); i ++)</span><br><span class="line">            res[i] = list.<span class="keyword">get</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="350-给定两个数组，编写一个函数来计算它们的交集。"><a href="#350-给定两个数组，编写一个函数来计算它们的交集。" class="headerlink" title="350.给定两个数组，编写一个函数来计算它们的交集。"></a>350.给定两个数组，编写一个函数来计算它们的交集。</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums1 = <span class="string">[1,2,2,1]</span>, nums2 = <span class="string">[2,2]</span></span><br><span class="line">输出: <span class="string">[2,2]</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums1 = <span class="string">[4,9,5]</span>, nums2 = <span class="string">[9,4,9,8,4]</span></span><br><span class="line">输出: <span class="string">[4,9]</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。<br>我们可以不考虑输出结果的顺序。<br>进阶:</p>
<p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p>
<p>分析：由于我们需要对重复的元素进行计数，可以设计一个映射。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;<span class="comment">//基于平衡二叉树（红黑树）的底层实现</span></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个integer指相应的元素，第二个指相应元素出现的频次</span></span><br><span class="line">        TreeMap&lt;Integer,Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> num: nums1)&#123;</span><br><span class="line">            <span class="built_in">if</span>(!<span class="built_in">map</span>.containsKey(num))<span class="comment">//判断是否相同</span></span><br><span class="line">                <span class="built_in">map</span>.<span class="built_in">put</span>(num,<span class="number">1</span>);<span class="comment">//放置元素，两个put的调用相当于我们自己写的set和add方法，我们没有合一，是因为这两个方法语义上一个叫添加一个叫设置，java标准库中采用的是换了一个词put，它认为不管是添加还是设置都是可以统一的</span></span><br><span class="line">            <span class="built_in">else</span></span><br><span class="line">                <span class="built_in">map</span>.<span class="built_in">put</span>(num, <span class="built_in">map</span>.<span class="built_in">get</span>(num) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> num: nums2)&#123;</span><br><span class="line">            <span class="built_in">if</span>(<span class="built_in">map</span>.containsKey(num))&#123;<span class="comment">//找到了一个交集元素，存储到list，</span></span><br><span class="line">                list.add(num);</span><br><span class="line">                <span class="built_in">map</span>.<span class="built_in">put</span>(num,<span class="built_in">map</span>.<span class="built_in">get</span>(num) - <span class="number">1</span>);<span class="comment">//由于我们映射中存储的是频次，因此要进行减1操作</span></span><br><span class="line">                <span class="built_in">if</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(num) == <span class="number">0</span>)<span class="comment">//如果对应频次变成0，我们可以直接删除</span></span><br><span class="line">                    <span class="built_in">map</span>.<span class="built_in">remove</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; list.<span class="built_in">size</span>() ; i ++)</span><br><span class="line">            res[i] = list.<span class="built_in">get</span>(i);</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这些接口虽然底层实现不同，<br>但是使用起来并没有障碍，因为他们的接口是相同的，可以使用treeMap，threeSet实现哈希表的大多数问题，因为log（n）的时间复杂度是非常快的</p>
</div><div class="tags"><a href="/tags/数据结构/">数据结构</a></div><div class="post-nav"><a class="pre" href="/2019/09/05/宽字节注入/">宽字节注入</a><a class="next" href="/2019/08/25/OSI参考模型的理解/">OSI参考模型的理解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/信安之路/">信安之路</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础知识/">基础知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/web安全-ctf/" style="font-size: 15px;">web安全 ctf</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/10/06/六、Web页面解析的流程学习/">六、Web页面解析的流程学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/04/3.代码执行与命令执行/">代码执行与命令执行</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/20/2.文件包含/">文件包含</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/1.文件上传/">文件上传</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/desc相关例题/">desc相关注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/13/order by/">order by，insert相关注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/bool型盲注/">bool型盲注</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/基于时间盲注的部分相关函数/">基于时间盲注的部分相关函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/07/约束条件的安全测试——报错注入/">约束条件的安全测试_报错注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/05/宽字节注入/">宽字节注入</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a target="_blank"></a><ul></ul><a target="_blank"></a><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">人间且慢行.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-2" count="50" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>